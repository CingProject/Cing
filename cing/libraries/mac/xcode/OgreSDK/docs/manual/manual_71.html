<!DOCTYPE html PUBLIC "-//W3C//DTD HTML 4.01 Transitional//EN" "http://www.w3.org/TR/html401/loose.dtd">
<html>
<!-- Created on May, 26 2012 by texi2html 1.70 -->
<!--
Written by: Lionel Cons <Lionel.Cons@cern.ch> (original author)
            Karl Berry  <karl@freefriends.org>
            Olaf Bachmann <obachman@mathematik.uni-kl.de>
            and many others.
Maintained by: Many creative people <dev@texi2html.cvshome.org>
Send bugs and suggestions to <users@texi2html.cvshome.org>

-->
<head>
<title>OGRE Manual v1.8 ('Byatis'): 7.1 Stencil Shadows</title>

<meta name="description" content="OGRE Manual v1.8 ('Byatis'): 7.1 Stencil Shadows">
<meta name="keywords" content="OGRE Manual v1.8 ('Byatis'): 7.1 Stencil Shadows">
<meta name="resource-type" content="document">
<meta name="distribution" content="global">
<meta name="Generator" content="texi2html 1.70">
<meta http-equiv="Content-Type" content="text/html; charset=us-ascii">
<style type="text/css">
<!--
a.summary-letter {text-decoration: none}
pre.display {font-family: serif}
pre.format {font-family: serif}
pre.menu-comment {font-family: serif}
pre.menu-preformatted {font-family: serif}
pre.smalldisplay {font-family: serif; font-size: smaller}
pre.smallexample {font-size: smaller}
pre.smallformat {font-family: serif; font-size: smaller}
pre.smalllisp {font-size: smaller}
ul.toc {list-style: none}
body {  font-family: Verdana, Arial, Helvetica, sans-serif; font-size: 10pt; color: black; background-color: white}
a:link {  color: #003300; text-decoration: underline}
a:hover {  color: #F5BC52; text-decoration: underline}
a:visited {  color: #004400; text-decoration: underline}
li {  color: #003300; list-style-type: diamond; position: relative; left: -15px; clip:    rect(   )}
td {  font-size: 10pt}
th {  font-size: 10pt}

.MainHeader {  font-weight: bold; color: #F5BC52; background-color: #006600; font-size: 10pt}
.BorderHeader {  background-color: #999900; font-size: 8pt; font-weight: bold; color: #F5BC52; text-align: center} 	  
.MainContent { font-family: Verdana, Arial, Helvetica, sans-serif; font-size: 10pt; color: #CCFFCC } 	 
.BorderContent {  font-size: 8pt; color: #66CC33; border-color: black #666600 #666600; 
                  padding-top: 2px; padding-right: 2px; padding-bottom: 10px; padding-left: 2px;
                  margin-bottom: 2px; border-style: solid; 
                  border-top-width: 0px; border-right-width: 1px; border-bottom-width: 1px; border-left-width: 1px}
.NewsDate {  color: #CCFFCC; font-weight: bold}
.Annotation {  font-size: 10px}

H1, H2, H3 {
        background-color: #6b7d6b;
	color: white;
	padding: 2px;
	padding-left: 5px;
	border-style: solid;
	border-width: 1px;
	border-color: black;
}

H1 {
	text-align: center; 
}
H2 {
}
H3 {
    FONT-FAMILY: trebuchet ms,helvetica,arial;
}
pre {
	background-color: #eeffee;
	color: black;
	padding: 5px;
}
td.example {
	border-style: solid;
	border-width: 1px;
	border-color: black;
}
dt { color: #3D653D; font-weight: bold;}

A.qindex {} 	 
A.qindexRef {} 	 
A.el { text-decoration: none; font-weight: bold } 	 
A.elRef { font-weight: bold } 	 
A.code { text-decoration: none; font-weight: normal; color: Blue } 	 
A:visited.code { text-decoration: none; font-weight: normal; color: Navy } 	 
A:hover.code { text-decoration: underline; font-weight: normal; color: Blue } 	 
A.codeRef { font-weight: normal; color: #4444ee } 	 
DL.el { margin-left: -1cm } 	 
DIV.fragment { width: 100%; border: none; background-color: #003300 } 	 
DIV.ah { color: white; background-color: black; margin-bottom: 3; margin-top: 3 } 	 
DIV.groupHeader { margin-left: 16; margin-top: 12; margin-bottom: 6; font-weight: bold } 	 
DIV.groupText { margin-left: 16; font-style: italic; font-size: smaller } 	 
FONT.keyword       { color: #008000 } 	 
FONT.keywordtype   { color: #999920 } 	 
FONT.keywordflow   { color: #e0FF00 } 	 
FONT.comment       { color: #009900 } 	 
FONT.preprocessor  { color: #809020 } 	 
FONT.stringliteral { color: #002080 } 	 
FONT.charliteral   { color: #008080 }
.ex { 	 
     FONT-SIZE: 8pt; FONT-FAMILY: tahoma
}
CODE.keywordtype { 	 
     COLOR: #00ccff 	 
} 	 
CODE.keyword { 	 
     FONT-WEIGHT: bold; COLOR: #00ccff 	 
} 	 
CODE.fn { 	 
     COLOR: white; 	 
     FONT-WEIGHT: bold; 	 
} 	 
CODE.var { 	 
     COLOR: #dcdcdc; 	 
} 	 
CODE.macro { 	 
     COLOR: #809020; 	 
     FONT-WEIGHT: bold; 	 
 } 	 
CODE.comm { 	 
     COLOR: lime 	 
 }

CODE.num {
	COLOR: purple
	}
CODE.str {
	COLOR: #ffcc33;
	font-style: italic
}
/* Used for rendering members in API specification */

.mdTable
{
	background-color: #eeffee;
	color: #ED9C08;
        width: 100%;
	border-top-style: solid;
	border-top-color: black;
	border-top-width: 1px;
}

.md
{
	font-size: 12pt;
	font-weight: bold;
	color: 
}
.md A.el {
	color: #F5BC52;
}
.md A:link.el {
	color: #007700;
}
.md A:hover.el {
	color: #F5BC52;
}
.md A:visited.el {
	color: #229922;
}


.mdname1, .mdname
{
   font-size: 12pt;
   font-weight: normal;
   font-style: italic;
}

/* There's no class on the graph images in the API docs, but they're
all centered.  TODO: get doxygen to give them a class.  (This won't 
look terrible on any image, though, really.) */
center img {
	border-style: solid;
	border-width: 1px;
	border-color: #AACCAA;
}

.memItemLeft
{
	background-color: #eeffee;
}
.memItemRight
{
	background-color: #eeffee;
}


HR { height: 1px; }

-->
</style>


</head>

<body lang="en" bgcolor="#FFFFFF" text="#000000" link="#0000FF" vlink="#800080" alink="#FF0000">

<a name="NOD78"></a>
<a name="SEC316"></a>
<table cellpadding="1" cellspacing="1" border="0">
<tr><td valign="middle" align="left">[<a href="manual_70.html#SEC313" title="Previous section in reading order"> &lt; </a>]</td>
<td valign="middle" align="left">[<a href="manual_72.html#SEC324" title="Next section in reading order"> &gt; </a>]</td>
<td valign="middle" align="left"> &nbsp; </td>
<td valign="middle" align="left">[<a href="manual_70.html#SEC313" title="Beginning of this chapter or previous chapter"> &lt;&lt; </a>]</td>
<td valign="middle" align="left">[<a href="manual_70.html#SEC313" title="Up section"> Up </a>]</td>
<td valign="middle" align="left">[<a href="manual_75.html#SEC345" title="Next chapter"> &gt;&gt; </a>]</td>
<td valign="middle" align="left"> &nbsp; </td>
<td valign="middle" align="left"> &nbsp; </td>
<td valign="middle" align="left"> &nbsp; </td>
<td valign="middle" align="left"> &nbsp; </td>
<td valign="middle" align="left">[<a href="index.html#SEC_Top" title="Cover (top) of document">Top</a>]</td>
<td valign="middle" align="left">[<a href="manual_toc.html#SEC_Contents" title="Table of contents">Contents</a>]</td>
<td valign="middle" align="left">[Index]</td>
<td valign="middle" align="left">[<a href="manual_abt.html#SEC_About" title="About (help)"> ? </a>]</td>
</tr></table>
<hr size="1">
<h2 class="section"> 7.1 Stencil Shadows </h2>

<p>Stencil shadows are a method by which a 'mask' is created for the screen using a feature called the stencil buffer. This mask can be used to exclude areas of the screen from subsequent renders, and thus it can be used to either include or exclude areas in shadow. They are enabled by calling SceneManager::setShadowTechnique with a parameter of either <code>SHADOWTYPE_STENCIL_ADDITIVE</code> or <code>SHADOWTYPE_STENCIL_MODULATIVE</code>. Because the stencil can only mask areas to be either 'enabled' or 'disabled', stencil shadows have 'hard' edges, that is to say clear dividing lines between light and shadow - it is not possible to soften these edges.<br><br>

</p><p>In order to generate the stencil, 'shadow volumes' are rendered by extruding the silhouette of the shadow caster away from the light. Where these shadow volumes intersect other objects (or the caster, since self-shadowing is supported using this technique), the stencil is updated, allowing subsequent operations to differentiate between light and shadow. How exactly this is used to render the shadows depends on whether <a href="manual_73.html#SEC339">Modulative Shadows</a> or <a href="manual_74.html#SEC341">Additive Light Masking</a> is being used. Objects can both cast and receive stencil shadows, so self-shadowing is inbuilt. <br><br>

</p><p>The advantage of stencil shadows is that they can do self-shadowing simply on low-end hardware, provided you keep your poly count under control. In contrast doing self-shadowing with texture shadows requires a fairly modern machine (See section <a href="manual_72.html#SEC324">Texture-based Shadows</a>). For this reason, you're likely to pick stencil shadows if you need an accurate shadowing solution for an application aimed at older or lower-spec machines.<br><br> 

</p><p>The disadvantages of stencil shadows are numerous though, especially on more modern hardware. Because stencil shadows are a geometric technique, they are inherently more costly the higher the number of polygons you use, meaning you are penalized the more detailed you make your meshes. The fillrate cost, which comes from having to render shadow volumes, also escalates the same way. Since more modern applications are likely to use higher polygon counts, stencil shadows can start to become a bottleneck. In addition, the visual aspects of stencil shadows are pretty primitive - your shadows will always be hard-edged, and you have no possibility of doing clever things with shaders since the stencil is not available for manipulation there. Therefore, if your application is aimed at higher-end machines you should definitely consider switching to texture shadows (See section <a href="manual_72.html#SEC324">Texture-based Shadows</a>).

</p><p>There are a number of issues to consider which are specific to stencil shadows:
</p><ul>
<li><p> <a href="#ANC181">CPU Overhead</a>
</p></li><li><p> <a href="#ANC182">Extrusion distance</a>
</p></li><li><p> <a href="#ANC183">Camera far plane positioning</a>
</p></li><li><p> <a href="#ANC184">Mesh edge lists</a>
</p></li><li><p> <a href="#ANC185">The Silhouette Edge</a>
</p></li><li><p> <a href="#ANC186">Be realistic</a>
</p></li><li><p> <a href="#ANC187">Stencil Optimisations Performed By Ogre</a>
</p></li></ul>

<p><a name="ANC181"></a>
</p><a name="SEC317"></a>
<h3 class="subheading"> CPU Overhead </h3>
<p>Calculating the shadow volume for a mesh can be expensive, and it has to be done on the CPU, it is not a hardware accelerated feature. Therefore, you can find that if you overuse this feature, you can create a CPU bottleneck for your application. Ogre quite aggressively eliminates objects which cannot be casting shadows on the frustum, but there are limits to how much it can do, and large, elongated shadows (e.g. representing a very low sun position) are very difficult to cull efficiently. Try to avoid having too many shadow casters around at once, and avoid long shadows if you can. Also, make use of the 'shadow far distance' parameter on the SceneManager, this can eliminate distant shadow casters from the shadow volume construction and save you some time, at the expense of only having shadows for closer objects. Lastly, make use of Ogre's Level-Of-Detail (LOD) features; you can generate automatically calculated LODs for your meshes in code (see the Mesh API docs) or when using the mesh tools such as OgreXMLConverter and OgreMeshUpgrader. Alternatively, you can assign your own manual LODs by providing alternative mesh files at lower detail levels. Both methods will cause the shadow volume complexity to decrease as the object gets further away, which saves you valuable volume calculation time. 

</p><p><a name="ANC182"></a>
</p><a name="SEC318"></a>
<h3 class="subheading"> Extrusion distance </h3>
<p>When vertex programs are not available, Ogre can only extrude shadow volumes a finite distance from the object. If an object gets too close to a light, any finite extrusion distance will be inadequate to guarantee all objects will be shadowed properly by this object. Therefore, you are advised not to let shadow casters pass too close to light sources if you can avoid it, unless you can guarantee that your target audience will have vertex program capable hardware (in this case, Ogre extrudes the volume to infinity using a vertex program so the problem does not occur).<br><br>
When infinite extrusion is not possible, Ogre uses finite extrusion, either derived from the attenuation range of a light (in the case of a point light or spotlight), or a fixed extrusion distance set in the application in the case of directional lights. To change the directional light extrusion distance, use SceneManager::setShadowDirectionalLightExtrusionDistance. 

</p><p><a name="ANC183"></a>
</p><a name="SEC319"></a>
<h3 class="subheading"> Camera far plane positioning </h3>
<p>Stencil shadow volumes rely very much on not being clipped by the far plane. When you enable stencil shadows, Ogre internally changes the far plane settings of your cameras such that there is no far plane - i.e. it is placed at infinity (Camera::setFarClipDistance(0)). This avoids artifacts caused by clipping the dark caps on shadow volumes, at the expense of a (very) small amount of depth precision. 

</p><p><a name="ANC184"></a>
</p><a name="SEC320"></a>
<h3 class="subheading"> Mesh edge lists </h3>
<p>Stencil shadows can only be calculated when an 'edge list' has been built for all the geometry in a mesh. The official exporters and tools automatically build this for you (or have an option to do so), but if you create your own meshes, you must remember to build edge lists for them before using them with stencil shadows - you can do that by using OgreMeshUpgrade or OgreXmlConverter, or by calling Mesh::buildEdgeList before you export or use the mesh. If a mesh doesn't have edge lists, OGRE assumes that it is not supposed to cast stencil shadows.

</p><p><a name="ANC185"></a>
</p><a name="SEC321"></a>
<h3 class="subheading"> The Silhouette Edge </h3>
<p>Stencil shadowing is about finding a silhouette of the mesh, and projecting it away to form a volume. What this means is that there is a definite boundary on the shadow caster between light and shadow; a set of edges where where the triangle on one side is facing toward the light, and one is facing away. This produces a sharp edge around the mesh as the transition occurs. Provided there is little or no other light in the scene, and the mesh has smooth normals to produce a gradual light change in its underlying shading, the silhouette edge can be hidden - this works better the higher the tessellation of the mesh. However, if the scene includes ambient light, then the difference is far more marked. This is especially true when using <a href="manual_73.html#SEC339">Modulative Shadows</a>, because the light contribution of each shadowed area is not taken into account by this simplified approach, and so using 2 or more lights in a scene using modulative stencil shadows is not advisable; the silhouette edges will be very marked. Additive lights do not suffer from this as badly because each light is masked individually, meaning that it is only ambient light which can show up the silhouette edges.

</p><p><a name="ANC186"></a>
</p><a name="SEC322"></a>
<h3 class="subheading"> Be realistic </h3>
<p>Don't expect to be able to throw any scene using any hardware at the stencil shadow algorithm and expect to get perfect, optimum speed results. Shadows are a complex and expensive technique, so you should impose some reasonable limitations on your placing of lights and objects; they're not really that restricting, but you should be aware that this is not a complete free-for-all. 
</p><ul>
<li><p> Try to avoid letting objects pass very close (or even through) lights - it might look nice but it's one of the cases where artifacts can occur on machines not capable of running vertex programs.
</p></li><li><p> Be aware that shadow volumes do not respect the 'solidity' of the objects they pass through, and if those objects do not themselves cast shadows (which would hide the effect) then the result will be that you can see shadows on the other side of what should be an occluding object. 
</p></li><li><p> Make use of SceneManager::setShadowFarDistance to limit the number of shadow volumes constructed
</p></li><li><p> Make use of LOD to reduce shadow volume complexity at distance
</p></li><li><p> Avoid very long (dusk and dawn) shadows - they exacerbate other issues such as volume clipping, fillrate, and cause many more objects at a greater distance to require volume construction.  
</p></li></ul>
<br><br>

<p><a name="ANC187"></a>
</p><a name="SEC323"></a>
<h3 class="subheading"> Stencil Optimisations Performed By Ogre </h3>
<p>Despite all that, stencil shadows can look very nice (especially with <a href="manual_74.html#SEC341">Additive Light Masking</a>) and can be fast if you respect the rules above. In addition, Ogre comes pre-packed with a lot of optimisations which help to make this as quick as possible. This section is more for developers or people interested in knowing something about the 'under the hood' behaviour of Ogre.
</p><dl compact="compact">
<dt> Vertex program extrusion</dt>
<dd><p>As previously mentioned, Ogre performs the extrusion of shadow volumes in hardware on vertex program-capable hardware (e.g. GeForce3, Radeon 8500 or better). This has 2 major benefits; the obvious one being speed, but secondly that vertex programs can extrude points to infinity, which the fixed-function pipeline cannot, at least not without performing all calculations in software. This leads to more robust volumes, and also eliminates more than half the volume triangles on directional lights since all points are projected to a single point at infinity.
</p></dd>
<dt> Scissor test optimisation</dt>
<dd><p>Ogre uses a scissor rectangle to limit the effect of point / spot lights when their range does not cover the entire viewport; that means we save fillrate when rendering stencil volumes, especially with distant lights
</p></dd>
<dt> Z-Pass and Z-Fail algorithms</dt>
<dd><p>The Z-Fail algorithm, often attributed to John Carmack, is used in Ogre to make sure shadows are robust when the camera passes through the shadow volume. However, the Z-Fail algorithm is more expensive than the traditional Z-Pass; so Ogre detects when Z-Fail is required and only uses it then, Z-Pass is used at all other times.
</p></dd>
<dt> 2-Sided stenciling and stencil wrapping</dt>
<dd><p>Ogre supports the 2-Sided stenciling / stencil wrapping extensions, which when supported allow volumes to be rendered in a single pass instead of having to do one pass for back facing tris and another for front-facing tris. This doesn't save fillrate, since the same number of stencil updates are done, but it does save primitive setup and the overhead incurred in the driver every time a render call is made.
</p></dd>
<dt> Aggressive shadow volume culling</dt>
<dd><p>Ogre is pretty good at detecting which lights could be affecting the frustum, and from that, which objects could be casting a shadow on the frustum. This means we don't waste time constructing shadow geometry we don't need. Setting the shadow far distance is another important way you can reduce stencil shadow overhead since it culls far away shadow volumes even if they are visible, which is beneficial in practice since you're most interested in shadows for close-up objects.
</p></dd>
</dl>


<hr size="1">
<table cellpadding="1" cellspacing="1" border="0">
<tr><td valign="middle" align="left">[<a href="manual_70.html#SEC313" title="Previous section in reading order"> &lt; </a>]</td>
<td valign="middle" align="left">[<a href="manual_72.html#SEC324" title="Next section in reading order"> &gt; </a>]</td>
<td valign="middle" align="left"> &nbsp; </td>
<td valign="middle" align="left">[<a href="manual_70.html#SEC313" title="Beginning of this chapter or previous chapter"> &lt;&lt; </a>]</td>
<td valign="middle" align="left">[<a href="manual_70.html#SEC313" title="Up section"> Up </a>]</td>
<td valign="middle" align="left">[<a href="manual_75.html#SEC345" title="Next chapter"> &gt;&gt; </a>]</td>
<td valign="middle" align="left"> &nbsp; </td>
<td valign="middle" align="left"> &nbsp; </td>
<td valign="middle" align="left"> &nbsp; </td>
<td valign="middle" align="left"> &nbsp; </td>
<td valign="middle" align="left">[<a href="index.html#SEC_Top" title="Cover (top) of document">Top</a>]</td>
<td valign="middle" align="left">[<a href="manual_toc.html#SEC_Contents" title="Table of contents">Contents</a>]</td>
<td valign="middle" align="left">[Index]</td>
<td valign="middle" align="left">[<a href="manual_abt.html#SEC_About" title="About (help)"> ? </a>]</td>
</tr></table>
<p>
 <font size="-1">
  This document was generated by <em>David Rogers</em> on <em>May, 26 2012</em> using <a href="http://texi2html.cvshome.org/"><em>texi2html 1.70</em></a>.
 </font>
 <br>

</p>
</body>
</html>
