<!DOCTYPE html PUBLIC "-//W3C//DTD HTML 4.01 Transitional//EN" "http://www.w3.org/TR/html401/loose.dtd">
<html>
<!-- Created on May, 26 2012 by texi2html 1.70 -->
<!--
Written by: Lionel Cons <Lionel.Cons@cern.ch> (original author)
            Karl Berry  <karl@freefriends.org>
            Olaf Bachmann <obachman@mathematik.uni-kl.de>
            and many others.
Maintained by: Many creative people <dev@texi2html.cvshome.org>
Send bugs and suggestions to <users@texi2html.cvshome.org>

-->
<head>
<title>Geometry Changes In OGRE 0.12: 2.8.2 Updating Pixel Buffers</title>

<meta name="description" content="Geometry Changes In OGRE 0.12: 2.8.2 Updating Pixel Buffers">
<meta name="keywords" content="Geometry Changes In OGRE 0.12: 2.8.2 Updating Pixel Buffers">
<meta name="resource-type" content="document">
<meta name="distribution" content="global">
<meta name="Generator" content="texi2html 1.70">
<meta http-equiv="Content-Type" content="text/html; charset=us-ascii">
<style type="text/css">
<!--
a.summary-letter {text-decoration: none}
pre.display {font-family: serif}
pre.format {font-family: serif}
pre.menu-comment {font-family: serif}
pre.menu-preformatted {font-family: serif}
pre.smalldisplay {font-family: serif; font-size: smaller}
pre.smallexample {font-size: smaller}
pre.smallformat {font-family: serif; font-size: smaller}
pre.smalllisp {font-size: smaller}
ul.toc {list-style: none}
body {  font-family: Verdana, Arial, Helvetica, sans-serif; font-size: 10pt; color: black; background-color: white}
a:link {  color: #003300; text-decoration: underline}
a:hover {  color: #F5BC52; text-decoration: underline}
a:visited {  color: #004400; text-decoration: underline}
li {  color: #003300; list-style-type: diamond; position: relative; left: -15px; clip:    rect(   )}
td {  font-size: 10pt}
th {  font-size: 10pt}

.MainHeader {  font-weight: bold; color: #F5BC52; background-color: #006600; font-size: 10pt}
.BorderHeader {  background-color: #999900; font-size: 8pt; font-weight: bold; color: #F5BC52; text-align: center} 	  
.MainContent { font-family: Verdana, Arial, Helvetica, sans-serif; font-size: 10pt; color: #CCFFCC } 	 
.BorderContent {  font-size: 8pt; color: #66CC33; border-color: black #666600 #666600; 
                  padding-top: 2px; padding-right: 2px; padding-bottom: 10px; padding-left: 2px;
                  margin-bottom: 2px; border-style: solid; 
                  border-top-width: 0px; border-right-width: 1px; border-bottom-width: 1px; border-left-width: 1px}
.NewsDate {  color: #CCFFCC; font-weight: bold}
.Annotation {  font-size: 10px}

H1, H2, H3 {
        background-color: #6b7d6b;
	color: white;
	padding: 2px;
	padding-left: 5px;
	border-style: solid;
	border-width: 1px;
	border-color: black;
}

H1 {
	text-align: center; 
}
H2 {
}
H3 {
    FONT-FAMILY: trebuchet ms,helvetica,arial;
}
pre {
	background-color: #eeffee;
	color: black;
	padding: 5px;
}
td.example {
	border-style: solid;
	border-width: 1px;
	border-color: black;
}
dt { color: #3D653D; font-weight: bold;}

A.qindex {} 	 
A.qindexRef {} 	 
A.el { text-decoration: none; font-weight: bold } 	 
A.elRef { font-weight: bold } 	 
A.code { text-decoration: none; font-weight: normal; color: Blue } 	 
A:visited.code { text-decoration: none; font-weight: normal; color: Navy } 	 
A:hover.code { text-decoration: underline; font-weight: normal; color: Blue } 	 
A.codeRef { font-weight: normal; color: #4444ee } 	 
DL.el { margin-left: -1cm } 	 
DIV.fragment { width: 100%; border: none; background-color: #003300 } 	 
DIV.ah { color: white; background-color: black; margin-bottom: 3; margin-top: 3 } 	 
DIV.groupHeader { margin-left: 16; margin-top: 12; margin-bottom: 6; font-weight: bold } 	 
DIV.groupText { margin-left: 16; font-style: italic; font-size: smaller } 	 
FONT.keyword       { color: #008000 } 	 
FONT.keywordtype   { color: #999920 } 	 
FONT.keywordflow   { color: #e0FF00 } 	 
FONT.comment       { color: #009900 } 	 
FONT.preprocessor  { color: #809020 } 	 
FONT.stringliteral { color: #002080 } 	 
FONT.charliteral   { color: #008080 }
.ex { 	 
     FONT-SIZE: 8pt; FONT-FAMILY: tahoma
}
CODE.keywordtype { 	 
     COLOR: #00ccff 	 
} 	 
CODE.keyword { 	 
     FONT-WEIGHT: bold; COLOR: #00ccff 	 
} 	 
CODE.fn { 	 
     COLOR: white; 	 
     FONT-WEIGHT: bold; 	 
} 	 
CODE.var { 	 
     COLOR: #dcdcdc; 	 
} 	 
CODE.macro { 	 
     COLOR: #809020; 	 
     FONT-WEIGHT: bold; 	 
 } 	 
CODE.comm { 	 
     COLOR: lime 	 
 }

CODE.num {
	COLOR: purple
	}
CODE.str {
	COLOR: #ffcc33;
	font-style: italic
}
/* Used for rendering members in API specification */

.mdTable
{
	background-color: #eeffee;
	color: #ED9C08;
        width: 100%;
	border-top-style: solid;
	border-top-color: black;
	border-top-width: 1px;
}

.md
{
	font-size: 12pt;
	font-weight: bold;
	color: 
}
.md A.el {
	color: #F5BC52;
}
.md A:link.el {
	color: #007700;
}
.md A:hover.el {
	color: #F5BC52;
}
.md A:visited.el {
	color: #229922;
}


.mdname1, .mdname
{
   font-size: 12pt;
   font-weight: normal;
   font-style: italic;
}

/* There's no class on the graph images in the API docs, but they're
all centered.  TODO: get doxygen to give them a class.  (This won't 
look terrible on any image, though, really.) */
center img {
	border-style: solid;
	border-width: 1px;
	border-color: #AACCAA;
}

.memItemLeft
{
	background-color: #eeffee;
}
.memItemRight
{
	background-color: #eeffee;
}


HR { height: 1px; }

-->
</style>


</head>

<body lang="en" bgcolor="#FFFFFF" text="#000000" link="#0000FF" vlink="#800080" alink="#FF0000">

<a name="NOD19"></a>
<a name="SEC27"></a>
<table cellpadding="1" cellspacing="1" border="0">
<tr><td valign="middle" align="left">[<a href="vbo-update_18.html#SEC23" title="Previous section in reading order"> &lt; </a>]</td>
<td valign="middle" align="left">[<a href="vbo-update_20.html#SEC30" title="Next section in reading order"> &gt; </a>]</td>
<td valign="middle" align="left"> &nbsp; </td>
<td valign="middle" align="left">[<a href="vbo-update_3.html#SEC3" title="Beginning of this chapter or previous chapter"> &lt;&lt; </a>]</td>
<td valign="middle" align="left">[<a href="vbo-update_17.html#SEC22" title="Up section"> Up </a>]</td>
<td valign="middle" align="left">[ &gt;&gt; ]</td>
<td valign="middle" align="left"> &nbsp; </td>
<td valign="middle" align="left"> &nbsp; </td>
<td valign="middle" align="left"> &nbsp; </td>
<td valign="middle" align="left"> &nbsp; </td>
<td valign="middle" align="left">[<a href="index.html#SEC_Top" title="Cover (top) of document">Top</a>]</td>
<td valign="middle" align="left">[Contents]</td>
<td valign="middle" align="left">[Index]</td>
<td valign="middle" align="left">[<a href="vbo-update_abt.html#SEC_About" title="About (help)"> ? </a>]</td>
</tr></table>
<hr size="1">
<h3 class="subsection"> 2.8.2 Updating Pixel Buffers </h3>

<p>Pixel Buffers can be updated in two different ways; a simple, convenient way and a more difficult (but in some cases faster) method. Both methods make use of PixelBox objects (See section <a href="vbo-update_22.html#SEC35">Pixel boxes</a>) to represent image data in memory.

</p><a name="SEC28"></a>
<h3 class="subheading"> blitFromMemory </h3>

<p>The easy method to get an image into a PixelBuffer is by using HardwarePixelBuffer::blitFromMemory. This takes a PixelBox object and does all necessary pixel format conversion and scaling for you. For example, to create a manual texture and load an image into it, all you have to do is

</p><table><tr><td>&nbsp;</td><td><pre class="example">// Manually loads an image and puts the contents in a manually created texture
Image img;
img.load(&quot;elephant.png&quot;, &quot;General&quot;);
// Create RGB texture with 5 mipmaps
TexturePtr tex = TextureManager::getSingleton().createManual(
    &quot;elephant&quot;,
    &quot;General&quot;,
    TEX_TYPE_2D,
    img.getWidth(), img.getHeight(),
    5, PF_X8R8G8B8);
// Copy face 0 mipmap 0 of the image to face 0 mipmap 0 of the texture.
tex-&gt;getBuffer(0,0)-&gt;blitFromMemory(img.getPixelBox(0,0));
</pre></td></tr></table>
<a name="SEC29"></a>
<h3 class="subheading"> Direct memory locking </h3>

<p>A more advanced method to transfer image data from and to a PixelBuffer is to use locking. By locking a PixelBuffer
you can directly access its contents in whatever the internal format of the buffer inside the GPU is.

</p><table><tr><td>&nbsp;</td><td><pre class="example">/// Lock the buffer so we can write to it
buffer-&gt;lock(HardwareBuffer::HBL_DISCARD);
const PixelBox &amp;pb = buffer-&gt;getCurrentLock();

/// Update the contents of pb here
/// Image data starts at pb.data and has format pb.format
/// Here we assume data.format is PF_X8R8G8B8 so we can address pixels as uint32.
uint32 *data = static_cast&lt;uint32*&gt;(pb.data);
size_t height = pb.getHeight();
size_t width = pb.getWidth();
size_t pitch = pb.rowPitch; // Skip between rows of image
for(size_t y=0; y&lt;height; ++y)
{
    for(size_t x=0; x&lt;width; ++x)
    {
        // 0xRRGGBB -&gt; fill the buffer with yellow pixels
        data[pitch*y + x] = 0x00FFFF00;
    }
}

/// Unlock the buffer again (frees it for use by the GPU)
buffer-&gt;unlock();
</pre></td></tr></table>

<hr size="1">
<p>
 <font size="-1">
  This document was generated by <em>David Rogers</em> on <em>May, 26 2012</em> using <a href="http://texi2html.cvshome.org/"><em>texi2html 1.70</em></a>.
 </font>
 <br>

</p>
</body>
</html>
